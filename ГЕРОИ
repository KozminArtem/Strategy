Класс герой 
Параметры: 
1)положение на карте(x,y)
2)дальность ходьбы
2)уровень
3)принадлежность к игроку
4)массив с юнитами в армии
5)массив бонусов(в зависимости от рода войск, на атаку/здоровье/дебафф атаки)
6)опыт
7) бонусы на получения ресурсов типа получает в два раза больше золота, или там крестьяне быстрее строят 
8)имя
Методы:
	1)перемещение
	2)вступление в бой
	3)новый уровень(увеличить хар-тики бонусов)
	4)удалить юнит из армии
	5)получить юнит 
6)вывод суммарной военной силы приблизительный
7)вступление в город свой или вражеский
6)

Класс Военные юниты
лучники
пехота 
конница
осадные орудия
		Для всех военных:
герой, к которому привязан
урон(средний) 1-го юнита
дальность атаки юнита
положение на поле боя (x1,y1)	
	
здоровье 1-го юнита начальное(без баффов-число повышающее ) ->health 
здоровья осталось у верхнего юнита типа(2хп/5хп)->health_left
здоровье всего отряда складывается из -> (QUANTITY-1)*(health+buff)+health_left
дальность передвижения по полю боя
способности(статический массив баффов/дебаффов в зависимости от вида войск)
очередность ходьбы(инициатива)
		Методы:
	1)получить урон
	2)перемещение по полю боя
	3)нанести урон
	4)удалить юнит(деструктор)
	5)добавить юнит
	8)имя юнита
	9)изображение на поле боя	





Мы написали следующие классы: 
1)класс юнитов
Конструктор
Unit(int quantity = 0){
        QUANTITY = quantity;
    }

2)военных юнитов
Конструктор принимает значения:
 Hero hero, int quantity = 0, int health_one = 0, int left_health=0, int buff_health = 0, int damage_one = 0, int buff_damage = 0, int type_damage = 0, int devation_damage = 0, int travel_distance = 0, int buff_travel = 0, int left_travel = 0

Методы:
а)с нанесением урона(вероятность) 
b) получением урона
с)перемещение по полю боя
	
объясни метод мув
 void Move(direction dir, Map field) {
        if (dir == direction::up) {
            if (POS.Get_y() + 1 <= field.Get_size_y()) {
                if (field.Get_Tile(POS.Get_x(), POS.Get_y() + 1).is_passage()) {
                    tile_type next = field.Get_Tile(POS.Get_x(), POS.Get_y() + 1).Get_type();
                    if (next == forest && LEFT_TRAVEL >= 2) {
                        LEFT_TRAVEL -= 2;
                        POS = field.Get_Tile(POS.Get_x(), POS.Get_y() + 1);
                    }
                    if (next != forest && LEFT_TRAVEL >= 1) {
                        LEFT_TRAVEL -= 1;
                        POS = field.Get_Tile(POS.Get_x(), POS.Get_y() + 1);
                    }
                }
            }
        }
dir - направление, MAP field -  карта на которой происходит бой
юнит ходит на 1 клетку в  заданном направлении если он сможет (если на пути нет гор или ему хватит очков нередвижения)
что такое филд гет тайл из пэсейдж - проверка на то, что на эту клетку можно пройти
на реки, озера, горы пройти нельзя и метод ничего не сделает
если лес, то на проход потратится 2 очка перемещения, если ходить по диоганали - 2 очка, если по диагонали на лес - 3 очка
3) Класс тайл(клетка) конструктор:
Tile::Tile(int pos_x, int pos_y, tile_type pos_type) {
    x = pos_x;
    y = pos_y;
    type = pos_type;
    is_placed = false;
}
Принимает значение координаты в которой находится объект, и тип местности, которая будет на этой клетке.
is_placed- занята/незанята клетка (по умолчанию нет)
bool Tile::is_passage() {
    if (type == mountain || type == lake || type == river_horizontal || type == river_bridge_vertical) return false;
    else return true;
}
можно ли пройти на клетку
4)класс Map(карта) - класс карты (и боя и мира)
конструктор номер 1:
Map::Map(std::vector<std::vector<Tile>> map_data) {
    size_y = map_data.size();
    size_x = map_data[0].size();
    tile_array = map_data;
}

принимает вектор векторов клеток(map_data)
size_x/y - размер мира по оси x/y
tile-array - массив клеток, которой заполнится карта
конструктор номер 2:
Map::Map(int size_X, int size_Y) {
    size_x = size_X;
    size_y = size_Y;
    std::vector<std::vector<Tile>> map_data;
    map_data.resize(size_y);
    for (int i = 1; i != size_y + 1; i++) {
        std::vector<Tile> v;
        v.resize(size_x);
        for (int j = 1; j != size_x + 1; j++) {
            v[j - 1] = Tile(j, i, plain);
        }
        map_data[i - 1] = v;
    }
    tile_array = map_data;
}

принимает размер карты и заполняет всю карту полем.
5) класс Save - класс сохранения в текстовый файл
Конструктор:
Save::Save(std::string save_n, std::string save_loc) {
    std::ifstream read;
    read.open(save_loc + save_n + ".txt");
    if (!read.is_open()) {
        std::ofstream write;
        write.open(save_loc + save_n + ".txt");
        write.close();
    }
    read.close();
    save_file.open(save_loc + save_n + ".txt", std::fstream::in | std::fstream::out);
    save_location = save_loc;
    save_name = save_n;
}
принимает название текстового файла и место где этот файл лежит(папка)
создает файл (если его нет) для сохранения или просто открывает его
save_file - файл, куда идет сохранение
save_location - местоположение файла
save_name - имя файла
6) Класс Hero - класс героев 
Конструктор:
Hero::Hero(std::string Name, Map Field, int x, int y, std::string Player){
    name = Name;
    player = Player;
    pos = Field.Get_Tile(x, y);
    move = 3;
    level = 1;
    exp = 0;
    field = Field;
    army = std::vector<Unit>();
    buff_army = std::vector<float>();
    buff_resource = std::vector<float>();
}
принимает имя, карту мира на которой находится(int x, int y), принимает Игрока
Field.Get_Tile(x,y) - получает клетку с данными координатами на карте
Hero::Hero() {
}
это конструктор(по умолчанию) он чисто технически нужен, иначе ошибка в Military
Перемещение
void Hero::Move(direction dir) {
    if (dir == direction::up) {
        if (pos.Get_y() + 1 <= field.Get_size_y()) {
            if (field.Get_Tile(pos.Get_x(), pos.Get_y() + 1).is_passage()) {
                tile_type next = field.Get_Tile(pos.Get_x(), pos.Get_y() + 1).Get_type();
                if (next == forest && move >= 2) {
                    move -= 2;
                    pos = field.Get_Tile(pos.Get_x(), pos.Get_y() + 1);
                }
                if (next != forest && move >= 1) {
                    move -= 1;
                    pos = field.Get_Tile(pos.Get_x(), pos.Get_y() + 1);
                }
            }
        }
    }
Смотри класс военных.










ПРОДОЛЖЕНИЕ СТРАТЕГИИ
развитие класса героев 
Методы
получить опыт
получить уровень
добавить юнит в отряд
убрать юнит из отряда
(как происходит добавление и убирание из отряда это что? 
к герою закреплен массив юнитов добавлять в него и удалять из него)
метод вступления в бой: 
лучше сделать в радиусе типа n клеток вокруг, и n зависит от величины армии
(берем вектор юнитов, считаем его длину, складываем всего quantity получаем количество людей суммарно в армии, из него считаем этот радиус. типа 0-200 - 1 клетка, 200-400  - 2 клетки, … больше 1000 - 5 клеток.)
проверка если суммарное расстояние между героями меньше чем сумма их радиусов то начинается - бой.
при начале боя создаёт карту с учётом окржающей местности
как юниты распологаются в начале бояпусть будет стандартная расстановка и ее можно менять до боя у героя
Класс юнитов: 
1)принимает положение на карте боя (клетку) с координатой х, у - (pos)
2)вступить в бой с другим юнитом если он находится в зоне нападения атакующий наносит урон обороняющимя юнитам. передаёт другому юниту атаку в полученный урон
3) клетка куда атаковать юниту(проверка на наличие в этой клетке враждебного)
4) нападал ли он уже в этот ход
5) контратака если напал ближник на ближника то происходит контратака.



НОВЫЕ КЛАССЫ
класс ГОРОД
параметры:
размер на карте 16 клеток(4*4)
константы клетки положения на карте
название
принадлежность к игроку
массив зданий в городе
Массив ресурсов в городе
Массив юнитов мирных
Привязан ли какой герой к городу(если да какой)(пусть в городе будет герой - городовой) 
ну пусть у города есть какие-нибудь стены. оборона у города выше) 
величина города(от количества строений)		
	Методы
1)добавить здание
2)получить/потратить ресурсы 
3)передать армию герою и получить армию от героя
4)пустить героя в город(если дружественный)
5) переместить героя из города на карту мира
6) получить новых мирных юнитов(зависит от величины города)
7) привязать юнитов к зданию

класс СТРОЕНИЯ в городе
параметры:
1)принадлежность к городу
2)массив юнитов в здании
3)статический параметр: стоимость постройки и улучшения(массивом ресурсов)
4)Состояние строения непостроенно / построенно /улучшено 
Методы:
взять из города ресурсы
добавить в город ресурсы
поменять состояние строения - построить - улучшить
разместить юнитов в здании
убрать юнитов
Наследники:
1)Ратуша(приносит деньги)
2)казарма(наем)
3)церковь(лечит,дополнительно приносит деньги)
4)ферма(еда и свободные жители)
5)шахта(руда)
6)лесопилка(лес)
7)Университет(развитие армии в казарме открываются новые возможности а у зданий достпны улучшения)
8)Стены(размещение войск на стены)
9) сторожевые башни(атака наступающих и размещение войск в башни)

